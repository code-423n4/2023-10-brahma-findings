# BRAHMA FI GAS OPTIMIZATIONS

## INTRODUCTION
Highlighted below are optimizations exclusively targeting state-mutating functions and view/pure functions invoked by state-mutating functions. In the discussion that follows, only runtime gas is emphasized, given its inevitable dominance over deployment gas costs throughout the protocol's lifetime. 

Please be aware that some code snippets may be shortened to conserve space, and certain code snippets may include @audit tags in comments to facilitate issue explanations."



## [G-01] Redundant state variable getters
Getters for public state variables are automatically generated by the solidity compiler so there is no need to code them manually as this increases deployment cost.

### 3 Instances

1. #### Make `authorizedAddresses` mapping variable `private` or `internal` since a getter function was defined for it.
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L112
```solidity
file: contracts/src/core/AddressProvider.sol

35:    mapping(bytes32 => address) public authorizedAddresses;  //@audit generates a redundant getter function
.
.
.
112:    function getAuthorizedAddress(bytes32 _key) external view returns (address) {
113:        return authorizedAddresses[_key];
114:    }
```
The solidity compiler would automatically create a getter function for the `authorizedAddresses` mapping above since it is declared as a `public` variable but a getter function `getAuthorizedAddress()` was also declared in the contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `authorizedAddresses` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:
```diff
diff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol
index 5ec51f9..7d3a9d7 100644
--- a/contracts/src/core/AddressProvider.sol
+++ b/contracts/src/core/AddressProvider.sol
@@ -32,7 +32,7 @@ contract AddressProvider {
      * @notice keccak256 hash of authorizedAddress keys mapped to their addresses
      * @dev authorizedAddresses are updatable by governance
      */
-    mapping(bytes32 => address) public authorizedAddresses;
+    mapping(bytes32 => address) internal authorizedAddresses;
```

2. #### Make `registries` mapping variable `private` or `internal` since a getter function was defined for it.
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L121
```solidity
file: contracts/src/core/AddressProvider.sol

41:     mapping(bytes32 => address) public registries;  //@audit generates a redundant getter function
.
.
.
121:    function getRegistry(bytes32 _key) external view returns (address) {
122:        return registries[_key];
123:    }
```
The solidity compiler would automatically create a getter function for the `registries` mapping above since it is declared as a `public` variable but a getter function `getRegistry()` was also declared in the contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `registries` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:
```diff
diff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol
index 5ec51f9..0a2381b 100644
--- a/contracts/src/core/AddressProvider.sol
+++ b/contracts/src/core/AddressProvider.sol
@@ -38,7 +38,7 @@ contract AddressProvider {
      * @notice keccak256 hash of registry keys mapped to their addresses
      * @dev registries are only set once by governance and immutable
      */
-    mapping(bytes32 => address) public registries;
+    mapping(bytes32 => address) internal registries;
```

3. #### Make `registries` mapping variable `private` or `internal` since a getter function was defined for it.
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/WalletRegistry.sol#L63
```solidity
file: contracts/src/core/registries/WalletRegistry.sol

25:    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;  //@audit generates a redundant getter function

63:    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {
64:        return walletToSubAccountList[_wallet];
65;    }
```
The solidity compiler would automatically create a getter function for the `walletToSubAccountList` mapping above since it is declared as a `public` variable but a getter function `getSubAccountsForWallet()` was also declared in the contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `walletToSubAccountList` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:
```diff
diff --git a/contracts/src/core/registries/WalletRegistry.sol b/contracts/src/core/registries/WalletRegistry.sol
index afc2b7d..4554b7c 100644
--- a/contracts/src/core/registries/WalletRegistry.sol
+++ b/contracts/src/core/registries/WalletRegistry.sol
@@ -22,7 +22,7 @@ contract WalletRegistry is AddressProviderService {
     /// @notice subAccount addresses mapped to owner wallet
     mapping(address subAccount => address wallet) public subAccountToWallet;
     /// @notice wallet addresses mapped to list of subAccounts
-    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;
+    mapping(address wallet => address[] subAccountList) internal walletToSubAccountList;
     /// @notice address of wallet mapped to boolean indicating if it's a wallet
     mapping(address => bool) public isWallet;
```



## [G-02] Refactor external/internal function to avoid unnecessary SLOAD
The function below read storage slots that are previously read in the function that invokes it. We can refactor the external/internal functions to pass cached storage variables as stack variables and avoid the extra storage reads that would otherwise take place in the internal functions.

### 1 Instance
1. #### The `_updatePolicy()` internal function read storage slots that were read in the `updatePolicy` function that invokes it.
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/PolicyRegistry.sol#L42-#L66
```solidity
file: contracts/src/core/registries/PolicyRegistry.sol

35:    function updatePolicy(address account, bytes32 policyCommit) external {
36:        if (policyCommit == bytes32(0)) {
37:            revert PolicyCommitInvalid();
38:        }
39:
40:        WalletRegistry walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH));
41:
42:        bytes32 currentCommit = commitments[account];  //@audit 1st SLOAD
43:
.
.
.
58:        _updatePolicy(account, policyCommit);
59:    }
.
.
.
66:    function _updatePolicy(address account, bytes32 policyCommit) internal {
67:        emit UpdatedPolicyCommit(account, policyCommit, commitments[account]);  //@audit 2nd SLOAD
68:        commitments[account] = policyCommit;
69:    }
```
The `_updatePolicy()` function above reads storage for the value of `commitments[account]` thereby incurring an `SLOAD` and also has to re-evaluate the mapping to get the value but this storage value `commitments[account]` was also read in the `updatePolicy` function which invokes `_updatePolicy()` so we could refactor the code such that we replace the storage read and re-evaluation of the mapping `commitments[account]` in the `_updatePolicy` with a cheaper stack read. The diff below shows how the code could be refactored:
```diff
diff --git a/contracts/src/core/registries/PolicyRegistry.sol b/contracts/src/core/registries/Policy
index 559d5ca..b897fe6 100644                                                                       
--- a/contracts/src/core/registries/PolicyRegistry.sol                                              
+++ b/contracts/src/core/registries/PolicyRegistry.sol                                              
@@ -55,7 +55,7 @@ contract PolicyRegistry is AddressProviderService {                               
             revert UnauthorizedPolicyUpdate();                                                     
         }                                                                                          
         // solhint-enable no-empty-blocks                                                          
-        _updatePolicy(account, policyCommit);                                                      
+        _updatePolicy(account, policyCommit, currentCommit);                                       
     }                                                                                              
                                                                                                    
     /**                                                                                            
@@ -63,8 +63,8 @@ contract PolicyRegistry is AddressProviderService {                               
      * @param account address of account to set policy commit for                                  
      * @param policyCommit policy commit hash to set                                               
      */                                                                                            
-    function _updatePolicy(address account, bytes32 policyCommit) internal {                       
-        emit UpdatedPolicyCommit(account, policyCommit, commitments[account]);                     
+    function _updatePolicy(address account, bytes32 policyCommit, bytes32 currentCommit) internal {
+        emit UpdatedPolicyCommit(account, policyCommit, currentCommit);                            
         commitments[account] = policyCommit;                                                       
     }                                                                                              
 }                                                                                                  
```




## [G-03] Add unchecked blocks for subtractions where the operands cannot underflow
The solidity compiler introduces some checks to avoid an underflow, but in some scenarios where it is impossible for underflow to occur we can use unchecked blocks to have some gas savings.

### 1 Instance
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L162-#L166
```solidity
file: contracts/src/core/PolicyValidator.sol

156:    function _decompileSignatures(bytes calldata _signatures)
157:        internal
158:        pure
159:        returns (uint32 expiryEpoch, bytes memory validatorSignature)
160:    {
161:        uint256 length = _signatures.length;
162:        if (length < 8) revert InvalidSignatures();
163:
164:        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));  //@audit calculations can be uncheked
165:        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));  //@audit calculations can be uncheked
166:        validatorSignature = _signatures[length - 8 - sigLength:length - 8];  //@audit calculations can be uncheked
167:    }
```
In the `_decompileSignatures()` function above the following calculations were made `uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]))`, `expiryEpoch = uint32(bytes4(_signatures[length - 4:length]))`, `validatorSignature = _signatures[length - 8 - sigLength:length - 8]` but prior to these calculations the check `if (length < 8) revert InvalidSignatures()` was made which ensures that the value of the `length` variable should be greater or equal to 8 The code could be refactored as shown in the diff below: 
```diff
diff --git a/contracts/src/core/PolicyValidator.sol b/contracts/src/core/PolicyValidator.sol
index 70d672f..04eb07a 100644
--- a/contracts/src/core/PolicyValidator.sol
+++ b/contracts/src/core/PolicyValidator.sol
@@ -161,9 +161,13 @@ contract PolicyValidator is AddressProviderService, EIP712 {
         uint256 length = _signatures.length;
         if (length < 8) revert InvalidSignatures();

-        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));
-        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));
-        validatorSignature = _signatures[length - 8 - sigLength:length - 8];
+        unchecked {
+         uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));
+         expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));
+         validatorSignature = _signatures[length - 8 - sigLength:length - 8];
+        }
+
+
     }
```




## [G-04] Declaring Unnecessary variables
Some varibles were defined even though they are used once. Not defining variables can reduce gas cost and contract size.
### 1 Instance
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L63
```solidity
file: contracts/src/core/PolicyValidator.sol

54:    function isPolicySignatureValid(
55:        address account,
56:        address to,
57:        uint256 value,
58:        bytes memory data,
59:        Enum.Operation operation,
60:        bytes calldata signatures
61:    ) external view returns (bool) {
62:        // Get nonce from safe
63:        uint256 nonce = IGnosisSafe(account).nonce();  @audit unnecessary variable declaration
64:
65:        // Build transaction struct hash
66:        bytes32 transactionStructHash = TypeHashHelper._buildTransactionStructHash(
67:            TypeHashHelper.Transaction({
68:                to: to,
69:                value: value,
70:                data: data,
71:                operation: uint8(operation),
72:                account: account,
73:                executor: address(0),
74:                nonce: nonce
75:            })
76:        );
77:
78:        // Validate signature
79:        return isPolicySignatureValid(account, transactionStructHash, signatures);
80:    }
```
In the `isPolicySignatureValid()` function above declaring the `nonce` variable is unnecessary as it was only used once in the function we could use the `IGnosisSafe(account).nonce()` directly instead and save `3` gas units. The diff below shows how it could be refactored:  
```diff
diff --git a/contracts/src/core/PolicyValidator.sol b/contracts/src/core/PolicyValidator.sol
index 70d672f..0107a64 100644
--- a/contracts/src/core/PolicyValidator.sol
+++ b/contracts/src/core/PolicyValidator.sol
@@ -60,7 +60,6 @@ contract PolicyValidator is AddressProviderService, EIP712 {
         bytes calldata signatures
     ) external view returns (bool) {
         // Get nonce from safe
-        uint256 nonce = IGnosisSafe(account).nonce();

         // Build transaction struct hash
         bytes32 transactionStructHash = TypeHashHelper._buildTransactionStructHash(
@@ -71,7 +70,7 @@ contract PolicyValidator is AddressProviderService, EIP712 {
                 operation: uint8(operation),
                 account: account,
                 executor: address(0),
-                nonce: nonce
+                nonce: IGnosisSafe(account).nonce()
             })
         );
```




## [G-05] Calculations should be memoized rather than re-calculating them
In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls to pure functions and returning the cached result when the same inputs occur again.

### 1 Instance
1. #### Memoize `keccak256(_data)` computation
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/TransactionValidator.sol#L166
```solidity
file: contracts/src/core/TransactionValidator.sol

149:    function _isConsoleBeingOverriden(
150:        address _from,
151:        address _to,
152:        uint256 _value,
153:        bytes memory _data,
154:        Enum.Operation _operation
155:    ) internal pure returns (bool) {
.
.
.
165:        if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {
166:            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {  //@audit memoize keccak256(_data) calculation
167:                return true;
168:            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {
169:                return true;
170:            }
171:        }
172:
173:        return false;
174:    }
```
In the `_isConsoleBeingOverriden()` function above the computation `keccak256(_data)` in some scenarios would be computed twice. We could save the gas used in the subsequent computation if we memoize the computation i.e we cache the result of the calcultion the first time in a variable and use the variable in place of the subsequent calculations so that in scenarios where the `keccak256(_data)` computation would be calculated we would have reduce gas cost for the computation to just a stack read. The diff below shows how the code could be refactored:
```diff
diff --git a/contracts/src/core/TransactionValidator.sol b/contracts/src/core/TransactionValidator.sol
index f31fe06..f02cc78 100644
--- a/contracts/src/core/TransactionValidator.sol
+++ b/contracts/src/core/TransactionValidator.sol
@@ -163,9 +163,10 @@ contract TransactionValidator is AddressProviderService {
          * In case these conditions are met, the guard is being removed, return true
          */
         if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {
-            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {
+            bytes32 datahash = keccak256(_data);
+            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == datahash) {
                 return true;
-            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {
+            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == datahash) {
                 return true;
             }
         }
```


## [G-06] Multiple accesses of a array should use a local variable cache
The instances below point to the second+ access of a value inside an array, within a function. Caching an array's struct avoids re-calculating the array offsets into memory

### Proof of concept 
```solidity
struct Person {
    string name;
    uint age;
    uint id;
}

contract NoCacheArrayElement {

    Person[] students;

    function createStudents() external  {
        Person[] memory arrayOfPersons = new Person[](3); 
        Person memory newPerson1 = Person("Emmanuel", 15,1);
        Person memory newPerson2 = Person("Faustina", 16,2);
        Person memory newPerson3 = Person("Emmanuela", 14,3);

        arrayOfPersons[0] = newPerson1;
        arrayOfPersons[1] = newPerson2;
        arrayOfPersons[2] = newPerson3;

        _addNewSet(arrayOfPersons);
    }

    function _addNewSet(Person[] memory _persons) internal {
        uint len = _persons.length;
        unchecked {
            for(uint i; i < len; ++i) {
                Person memory newStudent = Person(_persons[i].name, _persons[i].age, _persons[i].id);
                students.push(newStudent);
            }
        }

    }
}
```
```
test for test/NoCacheArrayElement.t.sol:NoCacheArrayElementTest
[PASS] test_createStudents() (gas: 230357)
```

```solidity

struct Person {
    string name;
    uint age;
    uint id;
}

contract CacheArrayElement {

    Person[] students;

    function createStudents() external  {
        Person[] memory arrayOfPersons = new Person[](3); 
        Person memory newPerson1 = Person("Emmanuel", 15,1);
        Person memory newPerson2 = Person("Faustina", 16,2);
        Person memory newPerson3 = Person("Emmanuela", 14,3);

        arrayOfPersons[0] = newPerson1;
        arrayOfPersons[1] = newPerson2;
        arrayOfPersons[2] = newPerson3;

        _addNewSet(arrayOfPersons);
    }

    function _addNewSet(Person[] memory _persons) internal {
        uint len = _persons.length;
        unchecked {
            for(uint i; i < len; ++i) {
                Person memory myPerson = _persons[i];
                Person memory newStudent = Person(myPerson.name, myPerson.age, myPerson.id);
                students.push(newStudent);
            }
        }

    }
}
```
```
test for test/Counter.t.sol:CacheArrayElementTest
[PASS] test_createStudents() (gas: 230096)
```

### 1 Instance
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/SafeHelper.sol#L111
```solidity
file: contracts/src/libraries/SafeHelper.sol

103:    function _packMultisendTxns(Types.Executable[] memory _txns) internal pure returns (bytes memory packedTxns) {
104:        uint256 len = _txns.length;
105:        if (len == 0) revert InvalidMultiSendInput();
106:
107:        uint256 i = 0;
108:        do {
109:            // Enum.Operation.Call is 0
110:            uint8 call = uint8(Enum.Operation.Call);
111:            if (_txns[i].callType == Types.CallType.DELEGATECALL) {
112:                call = uint8(Enum.Operation.DelegateCall);
113:            } else if (_txns[i].callType == Types.CallType.STATICCALL) {
114:                revert InvalidMultiSendCall(i);
115:            }
116:
117:            uint256 calldataLength = _txns[i].data.length;
118:
119:            bytes memory encodedTxn = abi.encodePacked(
120:                bytes1(call), bytes20(_txns[i].target), bytes32(_txns[i].value), bytes32(calldataLength), _txns[i].data
121:            );
122:
123:            if (i != 0) {
124:                // If not first transaction, append to packedTxns
125:                packedTxns = abi.encodePacked(packedTxns, encodedTxn);
126:            } else {
127:                // If first transaction, set packedTxns to encodedTxn
128:                packedTxns = encodedTxn;
129:            }
130:
131:            unchecked {
132:                ++i;
133:            }
134:        } while (i < len);
135:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/libraries/SafeHelper.sol b/contracts/src/libraries/SafeHelper.sol
index 7830a80..93faa93 100644
--- a/contracts/src/libraries/SafeHelper.sol
+++ b/contracts/src/libraries/SafeHelper.sol
@@ -108,16 +108,17 @@ library SafeHelper {
         do {
             // Enum.Operation.Call is 0
             uint8 call = uint8(Enum.Operation.Call);
-            if (_txns[i].callType == Types.CallType.DELEGATECALL) {
+            Types.Executable memory txns = _txns[i]
+            if (txns.callType == Types.CallType.DELEGATECALL) {
                 call = uint8(Enum.Operation.DelegateCall);
-            } else if (_txns[i].callType == Types.CallType.STATICCALL) {
+            } else if (txns.callType == Types.CallType.STATICCALL) {
                 revert InvalidMultiSendCall(i);
             }

-            uint256 calldataLength = _txns[i].data.length;
+            uint256 calldataLength = txns.data.length;

             bytes memory encodedTxn = abi.encodePacked(
-                bytes1(call), bytes20(_txns[i].target), bytes32(_txns[i].value), bytes32(calldataLength), _txns[i].data
+                bytes1(call), bytes20(txns.target), bytes32(txns.value), bytes32(calldataLength), txns.data
             );

             if (i != 0) {
```




## [G-07] Bytes constants are more efficient than string constants
If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is cheaper in solidity.

### 2 Instances
1. #### Change `_NAME` and `_VERSION` to `bytes32` data-type in `PolicyValidator` contract
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L26
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L28
```solidity
file: contracts/src/core/PolicyValidator.sol

26:    string private constant _NAME = "PolicyValidator";
27:
28:    string private constant _VERSION = "1.0";
.
.
.
174:    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {
175:        return (_NAME, _VERSION);
175:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/core/PolicyValidator.sol b/contracts/src/core/PolicyValidator.sol
index 70d672f..a911d39 100644
--- a/contracts/src/core/PolicyValidator.sol
+++ b/contracts/src/core/PolicyValidator.sol
@@ -23,9 +23,9 @@ contract PolicyValidator is AddressProviderService, EIP712 {
     error InvalidSignatures();

     /// @notice EIP712 domain name
-    string private constant _NAME = "PolicyValidator";
+    bytes32 private constant _NAME = "PolicyValidator";
     /// @notice EIP712 domain version
-    string private constant _VERSION = "1.0";
+    bytes32 private constant _VERSION = "1.0";

     constructor(address _addressProvider) AddressProviderService(_addressProvider) {}

@@ -171,7 +171,7 @@ contract PolicyValidator is AddressProviderService, EIP712 {
      * @return name domainName
      * @return version domainVersion
      */
-    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {
+    function _domainNameAndVersion() internal pure override returns (bytes32, bytes32) {
         return (_NAME, _VERSION);
     }
 }
```

2. #### Change `_NAME` and `_VERSION` to `bytes32` data-type in `ExecutorPlugin` contract
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/ExecutorPlugin.sol#L53
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/ExecutorPlugin.sol#L55
```solidity
file: contracts/src/core/ExecutorPlugin.sol

53:    string private constant _NAME = "ExecutorPlugin";

55:    string private constant _VERSION = "1.0";
.
.
.
159:    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {
160:        return (_NAME, _VERSION);
161:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/core/ExecutorPlugin.sol b/contracts/src/core/ExecutorPlugin.sol
index a790269..f985c61 100644
--- a/contracts/src/core/ExecutorPlugin.sol
+++ b/contracts/src/core/ExecutorPlugin.sol
@@ -50,9 +50,9 @@ contract ExecutorPlugin is AddressProviderService, ReentrancyGuard, EIP712 {
     }

     /// @notice EIP712 domain name
-    string private constant _NAME = "ExecutorPlugin";
+    bytes32 private constant _NAME = "ExecutorPlugin";
     /// @notice EIP712 domain version
-    string private constant _VERSION = "1.0";
+    bytes32 private constant _VERSION = "1.0";

     /// @notice mapping of account to nonce of executors
     mapping(address account => mapping(address executor => uint256 nonce)) public executorNonce;
@@ -156,7 +156,7 @@ contract ExecutorPlugin is AddressProviderService, ReentrancyGuard, EIP712 {
      * @return name domainName
      * @return version domainVersion
      */
-    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {
+    function _domainNameAndVersion() internal pure override returns (bytes32, bytes32) {
         return (_NAME, _VERSION);
     }
 }
```




## [G-08]  Use named returns for local variables of pure functions where it is possible 

### Proof of Concept
```solidity
library NoNamedReturnArithmetic {
    
    function sum(uint256 num1, uint256 num2) internal pure returns(uint256){
        return num1 + num2;
    }
}

contract NoNamedReturn {
    using NoNamedReturnArithmetic for uint256;

    uint256 public stateVar;

    function add2State(uint256 num) public {
        stateVar = stateVar.sum(num);
    }
}
```
```solidity
test for test/NoNamedReturn.t.sol:NamedReturnTest
[PASS] test_Increment() (gas: 27639)
```

```solidity
library NamedReturnArithmetic {
    
    function sum(uint256 num1, uint256 num2) internal pure returns(uint256 theSum){
        theSum = num1 + num2;
    }
}

contract NamedReturn {
    using NamedReturnArithmetic for uint256;

    uint256 public stateVar;

    function add2State(uint256 num) public {
        stateVar = stateVar.sum(num);
    }
}
```
```solidity
test for test/NamedReturn.t.sol:NamedReturnTest
[PASS] test_Increment() (gas: 27613)
```

### Instances
1. #### Use named returns in the `__buildTransactionStructHash()` function
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/TypeHashHelper.sol#L64
```solidity
file: contracts/src/libraries/TypeHashHelper.sol

64:    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {
65:        return keccak256(
66:            abi.encode(
67:                TRANSACTION_PARAMS_TYPEHASH,
68:                txn.to,
69:                txn.value,
70:                keccak256(txn.data),
71:                txn.operation,
72:                txn.account,
73:                txn.executor,
74:                txn.nonce
75:            )
76:        );
77:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/libraries/TypeHashHelper.sol b/contracts/src/libraries/TypeHashHelper.sol
index df1a5aa..64e0ed0 100644
--- a/contracts/src/libraries/TypeHashHelper.sol
+++ b/contracts/src/libraries/TypeHashHelper.sol
@@ -61,8 +61,8 @@ library TypeHashHelper {
      * @param txn transaction params struct
      * @return transactionStructHash
      */
-    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {
-        return keccak256(
+    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32 trxHash) {
+        trxHash = keccak256(
             abi.encode(
                 TRANSACTION_PARAMS_TYPEHASH,
                 txn.to,
```

2. #### Use named returns in the `_buildValidationStructHash()` function
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/TypeHashHelper.sol#L84
```solidity
file: contracts/src/libraries/TypeHashHelper.sol

84:    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {
85:        return keccak256(
86:            abi.encode(
87:                VALIDATION_PARAMS_TYPEHASH,
88:                validation.transactionStructHash,
89:                validation.policyHash,
90:                validation.expiryEpoch
91:            )
92:        );
93:    }
```
```diff
diff --git a/contracts/src/libraries/TypeHashHelper.sol b/contracts/src/libraries/TypeHashHelper.sol
index df1a5aa..6df88fc 100644
--- a/contracts/src/libraries/TypeHashHelper.sol
+++ b/contracts/src/libraries/TypeHashHelper.sol
@@ -81,8 +81,8 @@ library TypeHashHelper {
      * @param validation validation params struct
      * @return validationStructHash
      */
-    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {
-        return keccak256(
+    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32 validationHash) {
+        validationHash = keccak256(
             abi.encode(
                 VALIDATION_PARAMS_TYPEHASH,
                 validation.transactionStructHash,
```

3. #### Use named returns in the `_generateSingleThresholdSignature()` function
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/SafeHelper.sol#L84
```solidity
file: contracts/src/libraries/SafeHelper.sol

87:    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory) {
88:        bytes memory signatures = abi.encodePacked(
89:            bytes12(0), // Padding for signature verifier address
90:            bytes20(owner), // Signature Verifier
91:            bytes32(0), // Position of extra data bytes (last set of data)
92:            bytes1(hex"01") // Signature Type - 1 (presigned transaction)
93:        );
94:        return signatures;
95:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/libraries/SafeHelper.sol b/contracts/src/libraries/SafeHelper.sol                        
index 7830a80..4497e00 100644                                                                                       
--- a/contracts/src/libraries/SafeHelper.sol                                                                        
+++ b/contracts/src/libraries/SafeHelper.sol                                                                        
@@ -84,14 +84,13 @@ library SafeHelper {                                                                            
      * @param owner Owner of the safe                                                                              
      * @return signatures bytes array containing single pre validated owner signature                              
      */                                                                                                            
-    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory) {               
-        bytes memory signatures = abi.encodePacked(                                                                
+    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory signatures) {    
+        signatures = abi.encodePacked(                                                                             
             bytes12(0), // Padding for signature verifier address                                                  
             bytes20(owner), // Signature Verifier                                                                  
             bytes32(0), // Position of extra data bytes (last set of data)                                         
             bytes1(hex"01") // Signature Type - 1 (presigned transaction)                                          
         );                                                                                                         
-        return signatures;                                                                                         
     }                                                                                                              
                                                                                                                    
     /**                                                                                                            
```

## [G-09] Use modifiers rather than invoking functions to perform checks
Using modifiers in place of function to perform checks we could reduce the gas cost by up to `40` units because in using modifiers the solidity compiler would inline the operations of the modifier in the called function but using functions to perform checks would incur two `JUMPI` instructions plus the stack setup which could cost up to `40` gas units. Implementing this change would increase deployment cost but would reduce the the gas cost of the called functions so in the long run using modifiers would be cheaper. The functions below can also be made more gas efficient by making them  `payable` functions.

### Instances
1. ### Convert `_onlyDelegateCall()` function into a modifier
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeEnabler.sol#L81-#L83
```
file: contracts/src/core/SafeEnabler.sol

43:    function enableModule(address module) public {
44:        _onlyDelegateCall();     @audit use a modifier instead
45:
.
.
.
56:    }
.
.
.
66:    function setGuard(address guard) public {
67:        _onlyDelegateCall();     @audit use a modifier instead
68:
.
.
.
75:    }
.
.
.
81:    function _onlyDelegateCall() private view {    @audit convert to a modifier
82:        if (address(this) == _self) revert OnlyDelegateCall();
83:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/core/SafeEnabler.sol b/contracts/src/core/SafeEnabler.sol
index 02137cc..8f4b6de 100644
--- a/contracts/src/core/SafeEnabler.sol
+++ b/contracts/src/core/SafeEnabler.sol
@@ -29,6 +29,14 @@ contract SafeEnabler is GnosisSafeStorage {
     /// @dev keccak256("guard_manager.guard.address")
     bytes32 internal constant _GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;

+    /**
+     * @notice Validates if the current call being made is DELEGATECALL
+     * @dev reverts if not DELEGATECALL
+     */
+    modifier onlyDelegateCall {
+        if (address(this) == _self) revert OnlyDelegateCall();
+        _;
+    }
     constructor() {
         _self = address(this);
     }
@@ -40,8 +48,7 @@ contract SafeEnabler is GnosisSafeStorage {
      *  Refer https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/base/ModuleManager.sol#L32C5-L32C5
      * @param module Module to be whitelisted.
      */
-    function enableModule(address module) public {
-        _onlyDelegateCall();
+    function enableModule(address module) public payable onlyDelegateCall {

         // Module address cannot be null or sentinel.
         // solhint-disable-next-line custom-errors
@@ -63,8 +70,7 @@ contract SafeEnabler is GnosisSafeStorage {
      * @param guard address of the guard
      * @dev delegatecalled during initialization to bypass authorization modifier and set guard on safe
      */
-    function setGuard(address guard) public {
-        _onlyDelegateCall();
+    function setGuard(address guard) public payable onlyDelegateCall {

         bytes32 slot = _GUARD_STORAGE_SLOT;
         // solhint-disable-next-line no-inline-assembly
@@ -74,11 +80,4 @@ contract SafeEnabler is GnosisSafeStorage {
         emit ChangedGuard(guard);
     }
-    /**                                                                          
-     * @notice Validates if the current call being made is DELEGATECALL          
-     * @dev reverts if not DELEGATECALL                                          
-     */                                                                          
-    function _onlyDelegateCall() private view {                                  
-        if (address(this) == _self) revert OnlyDelegateCall();                   
-    }                                                                            
 }                                                                                     
```

2. ### Convert `_onlyGov()` function into a modifier
- https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L139-#L141
```solidity
file: contracts/src/core/AddressProvider.sol

52:     function setGovernance(address _newGovernance) external {
53:         _notNull(_newGovernance);
54:         _onlyGov();     @audit use a modifier instead
55:         emit GovernanceTransferRequested(governance, _newGovernance);
56:         pendingGovernance = _newGovernance;
57:     }
.
.
.
77:     function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {
78:         _onlyGov();     @audit use a modifier instead
79:         _notNull(_authorizedAddress);
80:
81:         /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true
82:         if (!_overrideCheck) {
83:             /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA
84:             if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);
85:         }
86:
87:         authorizedAddresses[_key] = _authorizedAddress;
88:
89:         emit AuthorizedAddressInitialised(_authorizedAddress, _key);
90:     }
.
.
.
97:     function setRegistry(bytes32 _key, address _registry) external {
98:         _onlyGov();     @audit use a modifier instead
99:         _ensureAddressProvider(_registry);
100:
101:        if (registries[_key] != address(0)) revert RegistryAlreadyExists();
102:        registries[_key] = _registry;
103:
104:        emit RegistryInitialised(_registry, _key);
105:    }
.
.
.
139:    function _onlyGov() internal view {    @audit convert to a modifier
140:        if (msg.sender != governance) revert NotGovernance(msg.sender);
141:    }
```
The code could be refactored as shown in the diff below:
```diff
diff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol
index 5ec51f9..6327ab1 100644
--- a/contracts/src/core/AddressProvider.sol
+++ b/contracts/src/core/AddressProvider.sol
@@ -40,6 +40,14 @@ contract AddressProvider {
      */
     mapping(bytes32 => address) public registries;

+    /**
+     * @notice Checks if msg.sender is governance
+     */
+    modifier onlyGov {
+        if (msg.sender != governance) revert NotGovernance(msg.sender);
+        _;
+    }
+
     constructor(address _governance) {
         _notNull(_governance);
         governance = _governance;
@@ -49,9 +57,8 @@ contract AddressProvider {
      * @notice Governance setter
      * @param _newGovernance address of new governance
      */
-    function setGovernance(address _newGovernance) external {
+    function setGovernance(address _newGovernance) external payable onlyGov {
         _notNull(_newGovernance);
-        _onlyGov();
         emit GovernanceTransferRequested(governance, _newGovernance);
         pendingGovernance = _newGovernance;
     }
@@ -74,8 +81,7 @@ contract AddressProvider {
      * @param _authorizedAddress address to set
      * @param _overrideCheck overrides check for supported address provider
      */
-    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {
-        _onlyGov();
+    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external payable onlyGov {
         _notNull(_authorizedAddress);

         /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true
@@ -94,8 +100,7 @@ contract AddressProvider {
      * @param _key key of registry address
      * @param _registry address to set
```




## CONCLUSION
As you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.

We strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.